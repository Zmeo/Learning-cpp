# C++
***


1.动态/静态类型

  - 静态类型：对象在声明时采用的类型，编译期确定。

  - 动态类型：一个指针或引用所指向的类型，运行期确定。
  
  - 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，编译期确定。
  
  - 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，运行期确定。
  
  - 非虚函数一般为静态绑定，虚函数一定为动态绑定（多态特性）。对象的动态类型可以更改，静态类型无法更改。在继承体系中，只有虚函数使用的是动态绑定，其他的是静态绑定。不要重新定义继承而来的非虚函数（virtual与缺省参数一起使用时注意动态和静态绑定），如下伪代码：
  
  ```C++
  class E
  {
      virtual func(int i=0);
  };
  class F:public E
  {
      virtual func(int i=1);
  };
  int main()
  {
      E* pf=new F();
      E* pe=pf;
      pe->func(); //此时调用子类F的func函数，但是使用基类E的默认参数，即 i=0
      //函数为动态绑定，但缺省参数为静态绑定
  }
  ```

2.拷贝构造函数
  
  - 对于一个类X，如果一个构造函数的第一个参数是下列之一，且没有其他参数或者其他参数都有默认值，那么这个函数就是拷贝构造函数，
  X&, const X&, volatile X&, const volatile X&
  
  - 一个类中可以存在多于一个的拷贝构造函数。
  
  - 如何防止默认拷贝的发生：声明一个私有拷贝构造，此时当用户试图按值传递时，发生编译错误。（扩展：单例模式、右值引用）
  
  - 当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。关于深浅拷贝、参数传递以及拷贝构造的使用[详见引用](https://www.cnblogs.com/alantu2018/p/8459250.html)。
  
 
