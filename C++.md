# C++
***

推荐书籍：

- 《primer》/《primer plus》（入门必看）；

- 牛客网C++面试真题题库（全面但不深入，可作为知识点提纲阅读）；

- 《深度探索C++对象模型》（详细剖析了类的构造析构，虚函数多态等相关知识，这一块在C++面试中必问）；

- 《STL源码剖析》（建议结合视频阅读，书很难啃，但侯捷课讲得不错）；

- 以上对付面试就够了，更加深入还有《modern effective C++》等书籍。

***

1.动态/静态类型

  - 静态类型：对象在声明时采用的类型，编译期确定。

  - 动态类型：一个指针或引用所指向的类型，运行期确定。
  
  - 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，编译期确定。
  
  - 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，运行期确定。
  
  - 非虚函数一般为静态绑定，虚函数一定为动态绑定（多态特性）。对象的动态类型可以更改，静态类型无法更改。在继承体系中，只有虚函数使用的是动态绑定，其他的是静态绑定。不要重新定义继承而来的非虚函数（virtual与缺省参数一起使用时注意动态和静态绑定），如下伪代码：
  
  ```C++
  class E
  {
      virtual func(int i=0);
  };
  class F:public E
  {
      virtual func(int i=1);
  };
  int main()
  {
      E* pf=new F();
      E* pe=pf;
      pe->func(); //此时调用子类F的func函数，但是使用基类E的默认参数，即 i=0
      //函数为动态绑定，但缺省参数为静态绑定
  }
  ```

2.拷贝构造函数
  
  - 对于一个类X，如果一个构造函数的第一个参数是下列之一，且没有其他参数或者其他参数都有默认值，那么这个函数就是拷贝构造函数，
  X&, const X&, volatile X&, const volatile X&。
  
  - 一个类中可以存在多于一个的拷贝构造函数。
  
  - 如何防止默认拷贝的发生：声明一个私有拷贝构造，此时当用户试图按值传递时，发生编译错误。（扩展：单例模式、右值引用）
  
  - 当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。
  
  关于深浅拷贝、参数传递以及拷贝构造的使用[详见引用](https://www.cnblogs.com/alantu2018/p/8459250.html)。
  
3.空结构体大小为1，枚举为int类型，大小为4。

4.什么时候会生成默认构造函数？

  - 如果一个类没有任何构造函数，但它包含一个成员对象（有默认构造函数），那么该类的隐式默认构造函数就有用（nontrival），编译器会为其合成默认构造函数，该构造会在真正被需要时调用。
  
  - 当一个类声明或继承一个虚函数时
  
  - 当一个类派生自一个集成串链，其中有一个或更多的虚基类。
  
  更多关于bitwise copy semantics的内容详见《深度探索C++对象模型》。
  
5.C++内存管理

  分区：堆、栈、自由存储区、全局/静态存储区、常量存储区。
  
  堆：new分配，delete释放/程序结束后系统回收。
  
  栈：存放局部变量，函数结束后回收。
  
  自由存储区：malloc/free。
  
  全局/静态存储区：C语言中又分为初始化和未初始化区域（.data, .bss）。
  
  常量区：不允许修改。
  
6.堆和栈的区别

  在32位系统中：

  - 堆的大小为4G，栈为1M。
  
  - 堆使用new/delete或malloc/free分配和释放内存，造成空间不连续。栈是一个先进后出的队列，通过编译器静态/动态分配。
  
  - 堆向上，向高地址方向增长。栈向下，向低地址方向增长。
  
  - 堆由C/C++函数库提供，效率较低。栈操作有相应的指令，使用寄存器效率较高。
  
7.野指针

  - 指针未初始化
  
  - 被free或delete后，未置NULL
  
  - 操作超过了变量的作用域范围
  
8.malloc/free，new/delete区别
  
  malloc/free是C++/C的标准库函数，(int*)malloc(sizeof(int)*length);
  
  new/delete是C++的运算符；
  
  如果用new创建对象数组，那么只能使用对象的无参构造函数。
  
9.main函数的返回值->int类型

  若main（）函数中没有显示return，编译器加上return int，返回0则表示成功，非0则函数执行失败。
  
  ```C++
  ./a.out && echo "Yes"
  在返回0的情况下输出：
  Yes
  在非0的情况下无输出
  ```
  
10.debug和release的区别

  调试版/发行版
  
  - 运行方式不同，debug增加调试代码，出错会定位。
  
  - 内存分配不同，debug自动初始化变量，release不会。
         
                debug以32位为单位分配，release以8位为单位。
  
  - assert在release中不编译，应使用verify。
  
  * 多线程情况下，调试会产生竞态（race condition）问题，因为debug包含了一些调试信息，会影响多线程的竞争状态，在有断点或单布运行时，一个线程停了另一个继续，这会破坏程序的并发性。
